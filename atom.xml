<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neighbor Wang&#39;s Station</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xycaicaicai.github.io/"/>
  <updated>2020-07-01T13:31:37.338Z</updated>
  <id>https://xycaicaicai.github.io/</id>
  
  <author>
    <name>XY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Distributed Computing Final</title>
    <link href="https://xycaicaicai.github.io/2020/06/16/Distributed-Computing-Final/"/>
    <id>https://xycaicaicai.github.io/2020/06/16/Distributed-Computing-Final/</id>
    <published>2020-06-16T09:42:38.000Z</published>
    <updated>2020-07-01T13:31:37.338Z</updated>
    
    <content type="html"><![CDATA[<ul><li>General Issues(2016-Q2, 2017-Q1, 2018-Q1, 2019-Q1 )</li></ul><p><em>主要都是Lecture 1 和 Lecture 2 中的内容</em></p><ol><li>understand definitions and goals of distributed system 分布式系统的定义是什么？<br>A distributed system is a collection of independent computers that are used jointly to perform a single task or to provide a single service.<a id="more"></a>The role of middleware in distributed system (2016-Q2-(a))<br>Answer: Role of middleware is to provide some degree of distribution transparency. Hiding distribution of data, processing and control.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;General Issues(2016-Q2, 2017-Q1, 2018-Q1, 2019-Q1 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;主要都是Lecture 1 和 Lecture 2 中的内容&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;understand definitions and goals of distributed system 分布式系统的定义是什么？&lt;br&gt;A distributed system is a collection of independent computers that are used jointly to perform a single task or to provide a single service.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Distributed-Computing-BlockChain</title>
    <link href="https://xycaicaicai.github.io/2020/05/29/Distributed-Computing-BlockChain/"/>
    <id>https://xycaicaicai.github.io/2020/05/29/Distributed-Computing-BlockChain/</id>
    <published>2020-05-29T09:44:32.000Z</published>
    <updated>2020-07-01T13:31:31.785Z</updated>
    
    <content type="html"><![CDATA[<p>##Essay Format</p><p>The marks for the sections provide a guide for how long the sections should be.</p><p>While it is not enforced, having section headings which align to the criterion makes sense (you can add further sub headings as you wish).<br><a id="more"></a><br><em>Clear introduction of the discussed topic - 400 words</em></p><p><em>Discussion of the distributed computing paradigm and/or architecture - 600 words</em></p><p><em>Discussion on issues related to communication, fault tolerance, consistency etc. - 600 words</em></p><h2 id="Example-applications-of-the-computing-paradigm-400-words"><a href="#Example-applications-of-the-computing-paradigm-400-words" class="headerlink" title="Example applications of the computing paradigm - 400 words"></a><em>Example applications of the computing paradigm - 400 words</em></h2><p>-Discussion on issues related to communication, fault     tolerance, consistency etc.</p><p>  You need to choose two issues, such as communication and synchronisation.</p><p>  You need to then provide real world examples of how these issues are addressed/implemented.</p><p>So for cloud computing paradigm you may have something like this (this is only a guide for those who are stuck):</p><p>  Communication in AWS (~125 words)</p><p>  Communication in Azure (~125 words)</p><p>  Synchronisation in AWS (~125 words)</p><p>  Synchronisation in Azure (~125 words)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##Essay Format&lt;/p&gt;
&lt;p&gt;The marks for the sections provide a guide for how long the sections should be.&lt;/p&gt;
&lt;p&gt;While it is not enforced, having section headings which align to the criterion makes sense (you can add further sub headings as you wish).&lt;br&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Distributed Computing" scheme="https://xycaicaicai.github.io/tags/Distributed-Computing/"/>
    
      <category term="Paper" scheme="https://xycaicaicai.github.io/tags/Paper/"/>
    
      <category term="Blockchain" scheme="https://xycaicaicai.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>MC9-Evaluating Models and Decision Trees</title>
    <link href="https://xycaicaicai.github.io/2020/05/26/MC9-Evaluating-Models-and-Decision-Trees/"/>
    <id>https://xycaicaicai.github.io/2020/05/26/MC9-Evaluating-Models-and-Decision-Trees/</id>
    <published>2020-05-26T10:43:47.000Z</published>
    <updated>2020-07-01T13:25:26.813Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Matlab" scheme="https://xycaicaicai.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>MC-Exam</title>
    <link href="https://xycaicaicai.github.io/2020/05/26/MC-Exam/"/>
    <id>https://xycaicaicai.github.io/2020/05/26/MC-Exam/</id>
    <published>2020-05-26T03:37:33.000Z</published>
    <updated>2020-07-01T13:32:11.563Z</updated>
    
    <content type="html"><![CDATA[<p>—————- Q5 ————————-<br><a href="https://zhuanlan.zhihu.com/p/53207761">https://zhuanlan.zhihu.com/p/53207761</a><br>5.2 Single-Linkage<br>—————- Q5 ————————-<br>—————- Q6 ————————-</p><h3 id="Q6-Gaussian-mixture-model"><a href="#Q6-Gaussian-mixture-model" class="headerlink" title="Q6 - Gaussian mixture model"></a>Q6 - Gaussian mixture model</h3><p>0.0422<br><em>给出混合高斯模型，计算模型在某点的概率密度</em><br>%创建高斯分布<br>mu = [1,2;-3,-5;0,1]<br>sig = cat(3,[2,0;0,0.5],[1,0;0,1],[0.6,0.5;0.5,1.6])<br>gm = gmdistribution(mu,sig)<br>%计算密度函数<br>x = [1.2,1.2]<br>x2 = [1.2;1.2]<br>end = pdf(gm,x)<br><a id="more"></a><br>—————– Q6 ————————</p><p>—————– Q7 ————————</p><h3 id="Q7-Mahalanobis-Distance"><a href="#Q7-Mahalanobis-Distance" class="headerlink" title="Q7 - Mahalanobis Distance"></a>Q7 - Mahalanobis Distance</h3><p>2.253521126760563<br><a href="https://blog.csdn.net/hustqb/article/details/90290232">https://blog.csdn.net/hustqb/article/details/90290232</a><br><em>性质</em><br>马氏距离消除了样本不同维度之间的方差差异和相关性，是一个无量纲的度量方式。<br><em>与欧式距离的关系</em><br>如果协方差矩阵是单位矩阵→\rightarrow→样本的特征维度间相关性（协方差）为0，量纲一致→\rightarrow→马氏距离等同于欧氏距离。<br>如果协方差矩阵是对角矩阵→\rightarrow→样本的特征维度间的量纲一致→\rightarrow→马氏距离等同于标准化后的欧氏距离。<br>% 总体的协方差矩阵为<br>S = [0.6,0.5;0.5,1.6]<br>x  = [1,1]<br>m = [0,1]<br>gm = gmdistribution(m,S)<br>d1 = mahal(gm, x)</p><p>—————– Q7 ————————</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;—————- Q5 ————————-&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53207761&quot;&gt;https://zhuanlan.zhihu.com/p/53207761&lt;/a&gt;&lt;br&gt;5.2 Single-Linkage&lt;br&gt;—————- Q5 ————————-&lt;br&gt;—————- Q6 ————————-&lt;/p&gt;
&lt;h3 id=&quot;Q6-Gaussian-mixture-model&quot;&gt;&lt;a href=&quot;#Q6-Gaussian-mixture-model&quot; class=&quot;headerlink&quot; title=&quot;Q6 - Gaussian mixture model&quot;&gt;&lt;/a&gt;Q6 - Gaussian mixture model&lt;/h3&gt;&lt;p&gt;0.0422&lt;br&gt;&lt;em&gt;给出混合高斯模型，计算模型在某点的概率密度&lt;/em&gt;&lt;br&gt;%创建高斯分布&lt;br&gt;mu = [1,2;-3,-5;0,1]&lt;br&gt;sig = cat(3,[2,0;0,0.5],[1,0;0,1],[0.6,0.5;0.5,1.6])&lt;br&gt;gm = gmdistribution(mu,sig)&lt;br&gt;%计算密度函数&lt;br&gt;x = [1.2,1.2]&lt;br&gt;x2 = [1.2;1.2]&lt;br&gt;end = pdf(gm,x)&lt;br&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Gaussian mixture model" scheme="https://xycaicaicai.github.io/tags/Gaussian-mixture-model/"/>
    
  </entry>
  
  <entry>
    <title>MC8-Kernel-Machines</title>
    <link href="https://xycaicaicai.github.io/2020/05/19/MC8-Kernel-Machines/"/>
    <id>https://xycaicaicai.github.io/2020/05/19/MC8-Kernel-Machines/</id>
    <published>2020-05-19T05:30:01.000Z</published>
    <updated>2020-07-01T13:33:04.647Z</updated>
    
    <content type="html"><![CDATA[<ol><li>通过 hold on 来实现在同一坐标上绘图</li></ol><hr><ol><li><p>核函数 Kernel Machines</p></li><li><p>SVM<br><a href="https://zhuanlan.zhihu.com/p/73477179">https://zhuanlan.zhihu.com/p/73477179</a><br>支持向量机中，对最好分类器的定义是：最大边界超平面，即距两个类别的边界观测点最远的超平面。在二维情况下，就是找最宽的马路，在三维问题中，就是找最厚的木板。</p><a id="more"></a></li></ol><p><a href="https://zhuanlan.zhihu.com/p/74484361">https://zhuanlan.zhihu.com/p/74484361</a></p><hr><p>Q3  A Kernel for Text Sequences- A Step beyond Words 关于文本匹配相似度（需要再全面了解一下）<br> A Kernel for Text Sequences- A Step beyond Words</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;通过 hold on 来实现在同一坐标上绘图&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;核函数 Kernel Machines&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SVM&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73477179&quot;&gt;https://zhuanlan.zhihu.com/p/73477179&lt;/a&gt;&lt;br&gt;支持向量机中，对最好分类器的定义是：最大边界超平面，即距两个类别的边界观测点最远的超平面。在二维情况下，就是找最宽的马路，在三维问题中，就是找最厚的木板。&lt;/p&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Matlab" scheme="https://xycaicaicai.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Database3</title>
    <link href="https://xycaicaicai.github.io/2020/05/11/Database3/"/>
    <id>https://xycaicaicai.github.io/2020/05/11/Database3/</id>
    <published>2020-05-11T10:06:49.000Z</published>
    <updated>2020-07-01T13:31:22.914Z</updated>
    
    <content type="html"><![CDATA[<hr><ol><li><p>通过 set 去统计list 中不同元素的个数</p></li><li><p>Database entity: It is a thing, person, place, unit, object or any item about which the data should be captured and stored in the form of properties, workflow and tables. While workflow and tables are optional for database entity, properties are required (because entity without properties is not an entity)</p><a id="more"></a></li><li>Data linkage: It is a method of bringing information from different sources together about the same person or entity to create a new, richer dataset.</li></ol><hr><h2 id="Data-Linkage"><a href="#Data-Linkage" class="headerlink" title="- Data Linkage"></a>- Data Linkage</h2><h3 id="Learning-objectives"><a href="#Learning-objectives" class="headerlink" title="Learning objectives"></a>Learning objectives</h3><p>  Data Linkage: is a method of bringing information from different sources together about the same person or entity to create a new, richer dataset.</p><p>• Learn how to use JDBC/cx_Oracle to interact with Oracle DBMS, including create table, update table, query table, etc. (optional)</p><p>  JDBC: Java Database Connectivity(JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is a Java-based data access technology used for Java database connectivity. It is part of the Java Standard Edition platform, from Oracle Corporation.</p><p>  Oracle DBMS<br>• Learn how to measure the performance of data linkage.</p><p>• Understand various string similarity measures, e.g., edit distance and Jaccard coefficient, for field-level data linkage.</p><p>• Understand the weighted-sum strategy for record-level data linkage.</p><h2 id="•-Understand-the-blocking-technique-used-for-improving-the-efficiency-of-data-linkage"><a href="#•-Understand-the-blocking-technique-used-for-improving-the-efficiency-of-data-linkage" class="headerlink" title="• Understand the blocking technique used for improving the efficiency of data linkage."></a>• Understand the blocking technique used for improving the efficiency of data linkage.</h2><h3 id="Part-2-Measure-the-Performance-of-Data-Linkagea"><a href="#Part-2-Measure-the-Performance-of-Data-Linkagea" class="headerlink" title="Part 2: Measure the Performance of Data Linkagea"></a>Part 2: Measure the Performance of Data Linkagea</h3><h4 id="1-Nested-Loop-Join-for-Data-Linkage"><a href="#1-Nested-Loop-Join-for-Data-Linkage" class="headerlink" title="1. Nested Loop Join for Data Linkage"></a>1. Nested Loop Join for Data Linkage</h4><h4 id="2-Precision-Recall-and-F-measure"><a href="#2-Precision-Recall-and-F-measure" class="headerlink" title="2. Precision, Recall, and F-measure"></a>2. Precision, Recall, and F-measure</h4><ol><li><p>Data Linkage: 可以被看作是一个分类问题，例如数据 r 和 s， 我们预测结果设置为 0 和 1. 当结果为 1 则意味着数据 r 和 s 指向的是同一个实体，因此可以被链接。</p></li><li><p>正确的数据链接算法必须满足以下条件：<br>1) all the linked pairs it predicts are correct<br>2) it can output all possible linked pairs.</p></li><li><p>在这个Task中 D 代表算法链接的结果，D<em>代表正确的链接结果<br>• True positive, if it belongs to both D and D</em></p><p>• False positive, if it only belongs to D</p><p>• False negative, if it only belongs to D*</p><p>• True negative, if it belongs to neither D nor D*</p><p>因此我们可以通过以下公式计算 precision 和 recall</p><p>𝑃𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛 = tp / 𝑡𝑝+𝑓𝑝 ：理解为精度</p><p>𝑅𝑒𝑐𝑎𝑙𝑙 = tp / 𝑡𝑝+𝑓𝑛 ：理解为召回<br>以切除肿瘤为例：更高的精确度降低了误切除健康细胞的机会(阳性结果)<br>但也降低了清除所有癌细胞的机会(阴性结果)。</p></li></ol><p>‘’’<br>解释两者关系，并引出 F-measure<br>Often, there is an inverse relationship between precision and recall, where it is possible to increase one at the cost of reducing the other. Brain surgery provides an illustrative example of the trade-off. Consider a brain surgeon tasked with removing a cancerous tumour from a patient’s brain. The surgeon needs to remove all of the tumour cells since any remaining cancer cells will regenerate the tumour. Conversely, the surgeon must not remove healthy brain cells since that<br>would leave the patient with impaired brain function. The surgeon may be more liberal in the area of the brain she removes to ensure she has extracted all the cancer cells. This decision increases recall but reduces precision. On the other hand, the surgeon may be more conservative in the brain she removes to ensure she extracts only cancer cells. This decision increases precision but reduces recall. That is to say, greater recall increases the chances of removing healthy cells (negative outcome) and increases the chances of removing all cancer cells (positive outcome). Greater precision decreases the chances of removing healthy cells (positive outcome)but also decreases the chances of removing all cancer cells (negative outcome). Therefore,another performance measure, F-measure, was proposed to combine precision and recall by their harmonic mean, as shown below.<br>‘’’<br>F = 2 <em> (precision </em> recall) / (precision + recall)<br> 疑问F为什么可以结合两者的特点-调和平均数<br>‘’’</p><p>####Task2<br>————-Answer:————————–<br>eg. “The false positive is the records that appear in both the linkage result and the gold-standard, which is corresponding to count/r esult.size(). There are 120 false positive pairs.”\</p><p>1) The true positive is the records that appear in both the linkage result and gold-standard, which is corresponding to<br>count. There are 75 true positive pairs.</p><p>2) The false positive and true positive are the records that  appear in the linkage result, which corresponding to the len(results). There are 82 false positives and true positive pairs.</p><p>3) The true positive and false negative are the records that  appear in gold-stand, which corresponding to the len(benchmark). There are 106 true positive and false negative pairs.</p><ul><li>In this case, precision means the proportion of the pairs that appear in both the results and benchmark in resluts.<br>(语法需要检查recall还没有写)</li></ul><hr><hr><h4 id="Part-3-Similarity-Measures-for-Field-Level-Data-Linkage"><a href="#Part-3-Similarity-Measures-for-Field-Level-Data-Linkage" class="headerlink" title="Part 3: Similarity Measures for Field-Level Data Linkage"></a>Part 3: Similarity Measures for Field-Level Data Linkage</h4><p>由于在大多数情况下，数据库中的数据是存在错误的拼写、不规范的数据等问题，所以我们需要通过计算记录之间的相似度去链接数据。这次作业主要用了两种方法</p><ol><li><p>Jaccard Coefficient(Jaccard index / Intersection over Union)</p><p>J(A,B) = |A∩B| / |A∪B| = |{0,2,5}| /|{0,1,2,3, 4,5,6,7,9}| = 3/9 = 0.33.<br>• A = {0,1,2,5,6}<br>• B = {0,2,3,4,5,7,9}</p><p>在这里因为我们要对字符串操作涉及到了顺序问题，所以可以采用 q-gram 的方法，例如 3-gram 下 “python” 这个单词会被划分为： pyt yth tho hon 四个</p></li></ol><p><em>Task 4</em></p><ol start="2"><li>Edit Distance<br><a href="https://www.jianshu.com/p/a617d20162cf">https://www.jianshu.com/p/a617d20162cf</a><br>编辑距离是指针对两个字符串 A 和 B，将A转化为B 所需要的最小编辑操作数，其中包括三种编辑操作：<br>• Insert a character into a string;<br>• Delete a character from a string;<br>• Replace a character of a string by another character.<br><em>在实际操作中不同的编辑是具有不同权重的，在这次实验中对此并无要求，所有权重都视为相同的权重</em></li></ol><hr><h2 id="Data-Pre-processing-Assignment"><a href="#Data-Pre-processing-Assignment" class="headerlink" title="Data Pre-processing Assignment"></a>Data Pre-processing Assignment</h2><p>————— Q1 - Start ——————-</p><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question - 1"></a>Question - 1</h3><p>1.1<br>  -What’s mean of Intergrity constraints?<br>    Intergrity constraints are a set of rules. It is used to maintain the quality of information. Integrity constraints ensure that the data insertion, updating, and other processes have be performed in such a way that data Integrity is nor effect<br>    完整性约束是指 一系列的规则。 他是被用来保证数据质量。 完整性约束确保数据的插入、更新以及其他操作不会影响数据的完整性。<br>1.2<br>  -What the intergity constraints should primary key follow?</p><pre><code>1. No two rows of a table have duplicate values in the specified colun or set of columns.不重复2.  The primary key do not allow nulls.不为空</code></pre><p>1.3<br>  What’s mean of schema?</p><p>1.3 Answer:<br>  (1)<br>    -The ‘id’ should be the primary              key for Book1. -<br>    -No duplicate values and No nulls.<br>  (2)</p><pre><code>- Book 3- SELECT TOP 100 Title, SalesRank from Book3 ORDER BY SalesRank</code></pre><p>————— Q1 - End ———————</p><p>————— Q2 - Start ——————-<br>2.1<br>  -Fragmentation strategy<br>  <a href="http://www.comp.hkbu.edu.hk/~wschow/dd/ch2.html">http://www.comp.hkbu.edu.hk/~wschow/dd/ch2.html</a><br>    Fragmentation is the task of dividing a table into a set of smaller tables. The subsets of the table are called fragments. Fragmentation can be of three types: horizontal, vertical, and hybrid (combination of horizontal and vertical).<br>    Fragmentation 就是将一个表分割成几个更小的表，分割得到的表叫做 fragments。 Fragmentation 有三种类型：水平、垂直、混合</p><p><em>Oracle 数据库导入CSV文件时 数据类型转换以及空值的问题</em><br>————— Q2 - End ———————</p><p>————— Q3 - Start ——————-<br>Lecture 5<br>————— Q3 - End ———————</p><p>————— Q4 - Start ——————-<br>Lecture 6<br>————— Q4 - End ———————</p><p>————— Q5 - Start ——————-</p><p>————— Q5 - End ———————</p><p>————— Q6 - Start ——————-</p><p>————— Q6 - End ———————</p><p>————— Q7 - Start ——————-<br>（1）<br>  a. “Richmond Shee, Kirtikumar Deshpande and K.    Gopalakrishnan;”<br>  b. “K. Gopalakrishnan, Kirtikumar Deshpande, and Richmond Shee”</p><p>For these two lists, the content is the same but the order is different. Thus, Jaccard distance is more likely to regard them as similar. Because Jaccard method will split the sting to a set. In this way, the distance between a and b is small.<br>In the contrast, edit distance calculate the distance by the number of steps which include insert,delete,replace. In this way, the distance will bigger because almost words have to be changed.</p><p>(2)</p><p>————— Q7 - End ———————</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过 set 去统计list 中不同元素的个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Database entity: It is a thing, person, place, unit, object or any item about which the data should be captured and stored in the form of properties, workflow and tables. While workflow and tables are optional for database entity, properties are required (because entity without properties is not an entity)&lt;/p&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Database" scheme="https://xycaicaicai.github.io/tags/Database/"/>
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Oracle" scheme="https://xycaicaicai.github.io/tags/Oracle/"/>
    
      <category term="Data Linkage" scheme="https://xycaicaicai.github.io/tags/Data-Linkage/"/>
    
  </entry>
  
  <entry>
    <title>MC7-Deep-Learning</title>
    <link href="https://xycaicaicai.github.io/2020/05/10/MC7-Deep-Learning/"/>
    <id>https://xycaicaicai.github.io/2020/05/10/MC7-Deep-Learning/</id>
    <published>2020-05-10T05:33:05.000Z</published>
    <updated>2020-07-01T13:32:54.024Z</updated>
    
    <content type="html"><![CDATA[<ol><li>如何理解什么是卷积（没有理解）<br><a href="https://www.zhihu.com/question/22298352">https://www.zhihu.com/question/22298352</a><br>两个函数的卷积，本质上是先将一个函数翻转，然后进行滑动叠加，在连续的情况下，叠加指的是对两个函数的乘积求积分，在离散的情况下就是加权求和</li><li>如何理解什么是池化<a id="more"></a></li></ol><hr><ol><li><p>Convolution Operation<br>多种卷积计算类型<br>数学中的卷积与深度学习中的卷积有什么区别？<br>Matlab中的CONV2（A,B）函数在计算时会对B矩 阵先进行180°的旋转</p></li><li><p>Pooling 池化<br>实际上是一种形式的降采样，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合<br> 特征不变形<br> 特征降维<br> 在一定程度上防止过拟合</p></li></ol><hr><ol><li>根据图6.6 可以看出随着深度的增加，网络的精确度也随之升高</li><li>根据图6.7  层数更深的网络“红色”拥有更好的表现，同时参数的增加也需要更深层网络模型去容纳这些参数，因此“蓝色”这种浅层的网络随着参数增加精度不会升高。”绿色全连接网络”的表现相对稳定，精度没有随着网络参数的增多发生明显起伏</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;如何理解什么是卷积（没有理解）&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/22298352&quot;&gt;https://www.zhihu.com/question/22298352&lt;/a&gt;&lt;br&gt;两个函数的卷积，本质上是先将一个函数翻转，然后进行滑动叠加，在连续的情况下，叠加指的是对两个函数的乘积求积分，在离散的情况下就是加权求和&lt;/li&gt;
&lt;li&gt;如何理解什么是池化
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Matlab" scheme="https://xycaicaicai.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>MC6-Neural-Networks</title>
    <link href="https://xycaicaicai.github.io/2020/05/05/MC6-Neural-Networks/"/>
    <id>https://xycaicaicai.github.io/2020/05/05/MC6-Neural-Networks/</id>
    <published>2020-05-05T05:09:23.000Z</published>
    <updated>2020-07-01T13:32:45.714Z</updated>
    
    <content type="html"><![CDATA[<p> 在这一章节，主要学习前馈神经网络（feedforward networks）, 多层感知器（multilayer perceptrons）</p><ul><li><p>Artificial Neurons<br>Q1<br>Write a short (approx. 2-4 sentences) explanation of why is it useful to have bias weights in a single or multi-layer perceptron (MLP)? Hint: use the example of a single neuron with a linear activation function and generalise to a larger network.</p><ol><li>Weights 权重: 每个输入信号的权重值，总和可以不是1</li><li>Bias 偏移:<a id="more"></a>Answer: Bias makes our model more flexible. In two dimensional linear model, bias is intercept to make model more consistent with data distribution. Moreover, different with other weights, bias can independent influence output.</li></ol><p>Q2</p><ol><li>Discriminant Function(判别/鉴别 函数)<br>目的： 是为了将归类的判断条件统一化</li><li>Training and Testing Error</li><li>The expected Generalisation Performance</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在这一章节，主要学习前馈神经网络（feedforward networks）, 多层感知器（multilayer perceptrons）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Artificial Neurons&lt;br&gt;Q1&lt;br&gt;Write a short (approx. 2-4 sentences) explanation of why is it useful to have bias weights in a single or multi-layer perceptron (MLP)? Hint: use the example of a single neuron with a linear activation function and generalise to a larger network.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Weights 权重: 每个输入信号的权重值，总和可以不是1&lt;/li&gt;
&lt;li&gt;Bias 偏移:
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Matlab" scheme="https://xycaicaicai.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Database2-DataWarehousing</title>
    <link href="https://xycaicaicai.github.io/2020/05/03/Database2-DataWarehousing/"/>
    <id>https://xycaicaicai.github.io/2020/05/03/Database2-DataWarehousing/</id>
    <published>2020-05-03T12:33:53.000Z</published>
    <updated>2020-07-01T13:31:17.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Data-Warehousing"><a href="#Data-Warehousing" class="headerlink" title="- Data Warehousing"></a>- Data Warehousing</h2><h3 id="Learning-objectives"><a href="#Learning-objectives" class="headerlink" title="Learning objectives"></a>Learning objectives</h3><p>• Learn how to create a cube and its dependent components in Oracle OLAP, including:<br>     Identify and build the dimensions<br>     Define measures (both stored and calculated)</p><p>• Learn how to map the OLAP model to source data and load data into the dimensions<br><a id="more"></a><br>• Learn how to view the OLAP data o Query through hierarchies o Perform operations like roll-up, drill-down, and pivot</p><p>• Understand how data is organized and stored in dimensions and data cubes</p><p>• Learn how to query a data cube using SQL queries</p><p>• Understand how materialized views are used in cube query optimization</p><hr><p>Preparation: Data Warehouse Setup<br>  Oracle OLAP<br>  AWM(Analytic Workspace Manager)</p><p>错误1：ORA-12560: TNS: 协议适配器错误<br>  是因为Oracle服务没有打开</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Data-Warehousing&quot;&gt;&lt;a href=&quot;#Data-Warehousing&quot; class=&quot;headerlink&quot; title=&quot;- Data Warehousing&quot;&gt;&lt;/a&gt;- Data Warehousing&lt;/h2&gt;&lt;h3 id=&quot;Learning-objectives&quot;&gt;&lt;a href=&quot;#Learning-objectives&quot; class=&quot;headerlink&quot; title=&quot;Learning objectives&quot;&gt;&lt;/a&gt;Learning objectives&lt;/h3&gt;&lt;p&gt;• Learn how to create a cube and its dependent components in Oracle OLAP, including:&lt;br&gt;     Identify and build the dimensions&lt;br&gt;     Define measures (both stored and calculated)&lt;/p&gt;
&lt;p&gt;• Learn how to map the OLAP model to source data and load data into the dimensions&lt;br&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Database" scheme="https://xycaicaicai.github.io/tags/Database/"/>
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Oracle" scheme="https://xycaicaicai.github.io/tags/Oracle/"/>
    
      <category term="OLAP" scheme="https://xycaicaicai.github.io/tags/OLAP/"/>
    
  </entry>
  
  <entry>
    <title>MC4-Clustering</title>
    <link href="https://xycaicaicai.github.io/2020/04/24/MC4-Clustering/"/>
    <id>https://xycaicaicai.github.io/2020/04/24/MC4-Clustering/</id>
    <published>2020-04-24T11:14:23.000Z</published>
    <updated>2020-07-01T13:26:11.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K-means-算法"><a href="#K-means-算法" class="headerlink" title="-K-means 算法"></a>-K-means 算法</h2><ol><li>流程：<br>1). 随机选取质心，对样本点分类，分类依据是距离K个质心的距离。<br>2). 对第一次分类之后的点分别求新的质心<br>3). 再次计算所有点到每个质心的距离、重新分类<br>4). 重复3、4 直到质心不再发生变化<a id="more"></a>——————-HW4 - Q2———————————</li><li>Reconstruction error/</li><li>PCA（Principal Component Analysis）常用于高维数据的降维， 可用于提取数据的主要特征分量。<br><a href="https://www.chegg.com/homework-help/questions-and-answers/take-dataset-400-points-need-divide-data-2-clusters-using-k-means-consider-one-iteration-e-q48295437">https://www.chegg.com/homework-help/questions-and-answers/take-dataset-400-points-need-divide-data-2-clusters-using-k-means-consider-one-iteration-e-q48295437</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;K-means-算法&quot;&gt;&lt;a href=&quot;#K-means-算法&quot; class=&quot;headerlink&quot; title=&quot;-K-means 算法&quot;&gt;&lt;/a&gt;-K-means 算法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;流程：&lt;br&gt;1). 随机选取质心，对样本点分类，分类依据是距离K个质心的距离。&lt;br&gt;2). 对第一次分类之后的点分别求新的质心&lt;br&gt;3). 再次计算所有点到每个质心的距离、重新分类&lt;br&gt;4). 重复3、4 直到质心不再发生变化
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Matlab" scheme="https://xycaicaicai.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Distributed-Computing-SmartWatch</title>
    <link href="https://xycaicaicai.github.io/2020/04/20/Distributed-Computing-SmartWatch/"/>
    <id>https://xycaicaicai.github.io/2020/04/20/Distributed-Computing-SmartWatch/</id>
    <published>2020-04-20T02:59:17.000Z</published>
    <updated>2020-07-01T13:31:47.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ICE-应用"><a href="#ICE-应用" class="headerlink" title="ICE 应用"></a>ICE 应用</h2><ol><li>所有ICE应用的第一步都是编写一个Slice定义， 其中包括应用所用的所有的各个接口</li><li>编写服务器并编译</li><li>编写客户并编译</li></ol><h2 id="R-I-Remote-method-invocation"><a href="#R-I-Remote-method-invocation" class="headerlink" title="R          I (Remote method invocation)"></a>R          I (Remote method invocation)</h2><ol><li>communicator</li><li>adapter -&gt; 适配器</li><li>创建代理： stringToProxy(服务器标识和服务器端口号)</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import com.zeroc.Ice.Communicator;</span><br><span class="line"></span><br><span class="line">public class Server</span><br><span class="line">&#123;</span><br><span class="line">private Communicator communicator;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建对象</span><br><span class="line">    Server server &#x3D; new Server();</span><br><span class="line">    &#x2F;&#x2F; 初始化communicator</span><br><span class="line">    server.communicator &#x3D; com.zeroc.Ice.Util.initialize(args);    </span><br><span class="line">    System.out.println(&quot;Server starting.&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建Adapter 并指定接口        </span><br><span class="line">        com.zeroc.Ice.ObjectAdapter adapter &#x3D; server.communicator.createObjectAdapterWithEndpoints(&quot;SimplePrinterAdapter&quot;, &quot;default -p 10001&quot;);</span><br><span class="line">        &#x2F;&#x2F; 初始化一个 PrinterI 的实例 叫做  object （定义于 Printer.java）</span><br><span class="line">        com.zeroc.Ice.Object object &#x3D; new PrinterI();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 给object 一个身份 -》 SimplePrinter 并激活 - 开始在上面指定的接口监听</span><br><span class="line">        adapter.add(object, com.zeroc.Ice.Util.stringToIdentity(&quot;SimplePrinter&quot;));</span><br><span class="line">        adapter.activate();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Adapter activated. Waiting for data.&quot;);</span><br><span class="line">        server.communicator.waitForShutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Server ending&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import com.zeroc.Ice.Communicator;</span><br><span class="line">import Demo.PrinterPrx;</span><br><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">private  PrinterPrx printerWorker;</span><br><span class="line">private  Communicator communicator;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化对象以及communicator</span><br><span class="line">    Client client &#x3D; new Client();</span><br><span class="line">    client.communicator &#x3D; com.zeroc.Ice.Util.initialize(args);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建代理 代理指向远程服务器的端口号 即指定的 adpator</span><br><span class="line">        com.zeroc.Ice.ObjectPrx base &#x3D; client.communicator.stringToProxy(&quot;SimplePrinter:default -p 10001&quot;);</span><br><span class="line">        &#x2F;&#x2F;返回了一个 SimplePrinter 的代理</span><br><span class="line">        client.printerWorker &#x3D; PrinterPrx.checkedCast(base);</span><br><span class="line"></span><br><span class="line">        if(client.printerWorker &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Error(&quot;Invalid proxy&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用了服务器的方法</span><br><span class="line">        client.printerWorker.printString(&quot;Hello World!&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">Thread thread &#x3D; new Thread() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while (bool &#x3D;&#x3D; true) &#123;</span><br><span class="line">SensorData data &#x3D; getSensorData();</span><br><span class="line">monitor.report(data);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.currentThread();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void runMonitor() &#123;</span><br><span class="line">  String topicName &#x3D; userName + &quot;Sensors&quot;;</span><br><span class="line">  com.zeroc.Ice.ObjectPrx obj &#x3D; communicator.stringToProxy(&quot;DemoIceStorm&#x2F;TopicManager:tcp -p 1000&quot;);</span><br><span class="line">  com.zeroc.IceStorm.TopicManagerPrx topicManager &#x3D; com.zeroc.IceStorm.TopicManagerPrx.checkedCast(obj);</span><br><span class="line">  TopicPrx topic &#x3D; null;</span><br><span class="line">  while (topic &#x3D;&#x3D; null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      topic &#x3D; topicManager.retrieve(topicName);</span><br><span class="line">    &#125; catch (com.zeroc.IceStorm.NoSuchTopic ex) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        topic &#x3D; topicManager.create(topicName);</span><br><span class="line">      &#125; catch (com.zeroc.IceStorm.TopicExists ex1) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  com.zeroc.Ice.ObjectPrx pub &#x3D; topic.getPublisher().ice_oneway();</span><br><span class="line">  monitor &#x3D; MonitorIcePrx.uncheckedCast(pub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###JAVA 语法积累：</p><ol><li>throws (AllSensors.java -&gt; main函数)<br>2.<br>-LinkedHashMap可以认为是HashMap+LinkedList，即它既使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序。<br>-LinkedHashMap的基本实现思想就是—-多态。可以说，理解多态，再去理解LinkedHashMap原理会事半功倍；反之也是，对于LinkedHashMap原理的学习，也可以促进和加深对于多态的理解。</li></ol><hr><h3 id="Publish-Subscribe-in-Ice"><a href="#Publish-Subscribe-in-Ice" class="headerlink" title="Publish/Subscribe in Ice"></a>Publish/Subscribe in Ice</h3><ol><li>IceStorm： 是 publish 和 subscribe 的中间层</li><li>IceStorm： 是单向通知消息</li><li>component/process： 用来显示从订阅主题（topic）接受消息的兴趣</li><li>topic： 类似与之前的Slice interface， 接口的一些操作-&gt;去定义了topic支持的数据类型</li><li>publisher 通过topic的代理（proxy）去发送消息，subscriber 继承topic的接口去接受消息</li></ol><hr><ul><li>实现发布订阅者</li></ul><ol><li>先得到 ‘TopicManger’ 的一个主题</li><li>获取具体的，比如 ‘Weather’ 主题的一个代理，如果主题不存在，就创建这个主题，否走就获得已有主题的代理</li><li>获取主题的 ‘发布对象’ 代理， 这个代理用来发布消息，因此被窄化成主题接口</li><li>收集并报告监测数据</li></ol><p>netstat -aon|findstr “8080”<br>taskkill -PID 进程号 -F</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ICE-应用&quot;&gt;&lt;a href=&quot;#ICE-应用&quot; class=&quot;headerlink&quot; title=&quot;ICE 应用&quot;&gt;&lt;/a&gt;ICE 应用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;所有ICE应用的第一步都是编写一个Slice定义， 其中包括应用所用的所有的各个接口&lt;/li&gt;
&lt;li&gt;编写服务器并编译&lt;/li&gt;
&lt;li&gt;编写客户并编译&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;R-I-Remote-method-invocation&quot;&gt;&lt;a href=&quot;#R-I-Remote-method-invocation&quot; class=&quot;headerlink&quot; title=&quot;R          I (Remote method invocation)&quot;&gt;&lt;/a&gt;R          I (Remote method invocation)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;communicator&lt;/li&gt;
&lt;li&gt;adapter -&amp;gt; 适配器&lt;/li&gt;
&lt;li&gt;创建代理： stringToProxy(服务器标识和服务器端口号)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Distributed Computing" scheme="https://xycaicaicai.github.io/tags/Distributed-Computing/"/>
    
      <category term="ICE" scheme="https://xycaicaicai.github.io/tags/ICE/"/>
    
      <category term="JAVA" scheme="https://xycaicaicai.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Social-Media-Analytics</title>
    <link href="https://xycaicaicai.github.io/2020/04/19/Social-Media-Analytics/"/>
    <id>https://xycaicaicai.github.io/2020/04/19/Social-Media-Analytics/</id>
    <published>2020-04-19T05:57:45.000Z</published>
    <updated>2020-07-01T13:33:12.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node-Betweenness-Centrality"><a href="#Node-Betweenness-Centrality" class="headerlink" title="- Node Betweenness Centrality"></a>- Node Betweenness Centrality</h3><ol><li><p>在无向图中，用所有最短路径经过这个点的次数来表示这个点的NBC</p></li><li><p>单源最短路径是指：给定源顶点到分别到其他顶点的最短路径的问题。</p></li></ol><h3 id="Page-Rank"><a href="#Page-Rank" class="headerlink" title="- Page Rank"></a>- Page Rank</h3><hr><h2 id="Graph-Embedding"><a href="#Graph-Embedding" class="headerlink" title="Graph Embedding"></a>Graph Embedding</h2><a id="more"></a><p>###Project 2 – Link Prediction<br>Network Embedding Models:</p><ul><li>Random walk based models: Deepwalk, Node2Vec,Line</li><li>Deep Neural Network based models: GCNs</li></ul><h4 id="GCNs"><a href="#GCNs" class="headerlink" title="GCNs"></a>GCNs</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Node-Betweenness-Centrality&quot;&gt;&lt;a href=&quot;#Node-Betweenness-Centrality&quot; class=&quot;headerlink&quot; title=&quot;- Node Betweenness Centrality&quot;&gt;&lt;/a&gt;- Node Betweenness Centrality&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在无向图中，用所有最短路径经过这个点的次数来表示这个点的NBC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单源最短路径是指：给定源顶点到分别到其他顶点的最短路径的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Page-Rank&quot;&gt;&lt;a href=&quot;#Page-Rank&quot; class=&quot;headerlink&quot; title=&quot;- Page Rank&quot;&gt;&lt;/a&gt;- Page Rank&lt;/h3&gt;&lt;hr&gt;
&lt;h2 id=&quot;Graph-Embedding&quot;&gt;&lt;a href=&quot;#Graph-Embedding&quot; class=&quot;headerlink&quot; title=&quot;Graph Embedding&quot;&gt;&lt;/a&gt;Graph Embedding&lt;/h2&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Python" scheme="https://xycaicaicai.github.io/tags/Python/"/>
    
      <category term="Data Structure" scheme="https://xycaicaicai.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>MC3- Multivariate Parametric Models and Density Estimation</title>
    <link href="https://xycaicaicai.github.io/2020/04/17/MC3-Multivariate-Parametric-Models-and-Density-Estimation/"/>
    <id>https://xycaicaicai.github.io/2020/04/17/MC3-Multivariate-Parametric-Models-and-Density-Estimation/</id>
    <published>2020-04-17T12:16:05.000Z</published>
    <updated>2020-07-01T13:24:54.307Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Matlab" scheme="https://xycaicaicai.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>MC2_Parametric Models</title>
    <link href="https://xycaicaicai.github.io/2020/04/16/MC2-Parametric-Models/"/>
    <id>https://xycaicaicai.github.io/2020/04/16/MC2-Parametric-Models/</id>
    <published>2020-04-16T06:10:58.000Z</published>
    <updated>2020-07-01T13:32:34.498Z</updated>
    
    <content type="html"><![CDATA[<p>问题：</p><ol><li>如何确定最高指数  </li><li>计算R^2 收藏夹 线性拟合求决定系数</li><li>如何判断是否过拟合：当训练集和测试集准确率相差太多就是过拟合  Overﬁtted (the is rougher than the true function and ﬁts towards the noise in the data).</li></ol><h5 id="nbsp-nbsp-Matlab-fit-fittype-fiteval（这部分是Q1-Q2-做多项式拟合）"><a href="#nbsp-nbsp-Matlab-fit-fittype-fiteval（这部分是Q1-Q2-做多项式拟合）" class="headerlink" title="&nbsp;&nbsp;Matlab: fit fittype fiteval（这部分是Q1 Q2 做多项式拟合）"></a>&nbsp;&nbsp;Matlab: fit fittype fiteval（这部分是Q1 Q2 做多项式拟合）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;(1) fit_model = fittype(‘gauss1’) 创建拟合模型<br><a id="more"></a></p><h5 id="nbsp-nbsp-Parametric-Probabilistic-Classiﬁcation-这部分是Q4-针对参数概率分类"><a href="#nbsp-nbsp-Parametric-Probabilistic-Classiﬁcation-这部分是Q4-针对参数概率分类" class="headerlink" title="&nbsp;&nbsp; Parametric Probabilistic Classiﬁcation(这部分是Q4 针对参数概率分类)"></a>&nbsp;&nbsp; Parametric Probabilistic Classiﬁcation(这部分是Q4 针对参数概率分类)</h5><ol><li>Maximum Likelihood Estimation(极大似然估计):</li></ol><p>1.1 目的是：利用已知的样本结果，反推最有可能导致这样结果的参数值,即 –模型已定 参数未知</p><p>1.2 那又何如去选取固定的模型呢？<br>  让样本结果出现的可能性最大</p><p>1.3 贝叶斯公式的理解（先验概率/后验概率）：</p><pre><code>先验概率： 是指根据以往经验和分析得到的概率后验概率： 事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小</code></pre><ol start="2"><li>Evaluating an Estimator: Bias and Variance</li></ol><h3 id="Multivariate-Parametric-Models-and-Density-Estimation"><a href="#Multivariate-Parametric-Models-and-Density-Estimation" class="headerlink" title="- Multivariate Parametric Models and Density Estimation"></a>- Multivariate Parametric Models and Density Estimation</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何确定最高指数  &lt;/li&gt;
&lt;li&gt;计算R^2 收藏夹 线性拟合求决定系数&lt;/li&gt;
&lt;li&gt;如何判断是否过拟合：当训练集和测试集准确率相差太多就是过拟合  Overﬁtted (the is rougher than the true function and ﬁts towards the noise in the data).&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;nbsp-nbsp-Matlab-fit-fittype-fiteval（这部分是Q1-Q2-做多项式拟合）&quot;&gt;&lt;a href=&quot;#nbsp-nbsp-Matlab-fit-fittype-fiteval（这部分是Q1-Q2-做多项式拟合）&quot; class=&quot;headerlink&quot; title=&quot;&amp;nbsp;&amp;nbsp;Matlab: fit fittype fiteval（这部分是Q1 Q2 做多项式拟合）&quot;&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;Matlab: fit fittype fiteval（这部分是Q1 Q2 做多项式拟合）&lt;/h5&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1) fit_model = fittype(‘gauss1’) 创建拟合模型&lt;br&gt;
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Homework" scheme="https://xycaicaicai.github.io/tags/Homework/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
      <category term="Matlab" scheme="https://xycaicaicai.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>MC start 02</title>
    <link href="https://xycaicaicai.github.io/2019/01/23/MC-start-02/"/>
    <id>https://xycaicaicai.github.io/2019/01/23/MC-start-02/</id>
    <published>2019-01-23T05:14:48.000Z</published>
    <updated>2020-07-01T13:32:29.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Well-known-algorithms"><a href="#Well-known-algorithms" class="headerlink" title="Well known algorithms"></a>Well known algorithms</h3><h4 id="1-K-Nearest-Neighbor"><a href="#1-K-Nearest-Neighbor" class="headerlink" title="1. K Nearest Neighbor"></a>1. K Nearest Neighbor</h4><h5 id="（1）-One-of-the-simplest-classfication-algorithms"><a href="#（1）-One-of-the-simplest-classfication-algorithms" class="headerlink" title="（1） One of the simplest classfication algorithms"></a>（1） One of the simplest<a id="more"></a> classfication algorithms</h5><h5 id="（2）-Often-used-in-classfication"><a href="#（2）-Often-used-in-classfication" class="headerlink" title="（2） Often used in classfication"></a>（2） Often used in classfication</h5><h5 id="（3）-Classiﬁcation-is-computed-from-a-simple-majority-vote-of-the-nearest-neighbors-of-each-point"><a href="#（3）-Classiﬁcation-is-computed-from-a-simple-majority-vote-of-the-nearest-neighbors-of-each-point" class="headerlink" title="（3） Classiﬁcation is computed from a simple majority vote of the nearest neighbors of each point"></a>（3） Classiﬁcation is computed from a simple majority vote of the nearest neighbors of each point</h5><!-- more --><h5 id="（4）-K-is-constant-speciﬁed-by-user"><a href="#（4）-K-is-constant-speciﬁed-by-user" class="headerlink" title="（4） K is constant speciﬁed by user"></a>（4） K is constant speciﬁed by user</h5><h5 id="（5）-KNN-is-computationally-expensive"><a href="#（5）-KNN-is-computationally-expensive" class="headerlink" title="（5） KNN is computationally expensive"></a>（5） KNN is computationally expensive</h5><h4 id="2-Support-Vector-Machine"><a href="#2-Support-Vector-Machine" class="headerlink" title="2. Support Vector Machine"></a>2. Support Vector Machine</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Well-known-algorithms&quot;&gt;&lt;a href=&quot;#Well-known-algorithms&quot; class=&quot;headerlink&quot; title=&quot;Well known algorithms&quot;&gt;&lt;/a&gt;Well known algorithms&lt;/h3&gt;&lt;h4 id=&quot;1-K-Nearest-Neighbor&quot;&gt;&lt;a href=&quot;#1-K-Nearest-Neighbor&quot; class=&quot;headerlink&quot; title=&quot;1. K Nearest Neighbor&quot;&gt;&lt;/a&gt;1. K Nearest Neighbor&lt;/h4&gt;&lt;h5 id=&quot;（1）-One-of-the-simplest-classfication-algorithms&quot;&gt;&lt;a href=&quot;#（1）-One-of-the-simplest-classfication-algorithms&quot; class=&quot;headerlink&quot; title=&quot;（1） One of the simplest classfication algorithms&quot;&gt;&lt;/a&gt;（1） One of the simplest
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
  </entry>
  
  <entry>
    <title>MC start 01</title>
    <link href="https://xycaicaicai.github.io/2018/11/28/MC-start-01/"/>
    <id>https://xycaicaicai.github.io/2018/11/28/MC-start-01/</id>
    <published>2018-11-28T05:14:42.000Z</published>
    <updated>2020-07-01T13:32:23.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-01"><a href="#Day-01" class="headerlink" title="Day 01"></a>Day 01</h2><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>&nbsp;&nbsp;大四一年所作的工作于论文都是基于：CV+MachingLearning, 回头去看，收获很多但是也深切感受到自己当初拖着课题几乎是盲目的去工作，走了很多弯路，自己也缺乏完整的知识体系，恰巧在机器之心上看到一封开源教材 Getting Started With Maching Learning 来自SAP（全球第一大商业软件公司）的梁劲（Jim Liang）公开了自己所写的一份 520 页的学习教程（英文版），详细、明了地介绍了机器学习中的相关概念、数学知识和各种经典算法。准备以此为脉络，研究生之前构架自己的知识体系。<a id="more"></a>在学习每节内容之后，尽量设计可以体现该节知识的demo。  <!-- more --><br>&nbsp;&nbsp; 主要关注于第二章算法的实现部分，在基础概念介绍部分原文十分详细、图表也更丰富，所以不再做画蛇添足的工作。</p><h3 id="The-Fundamental-of-Concept-原文详尽且形象"><a href="#The-Fundamental-of-Concept-原文详尽且形象" class="headerlink" title="The Fundamental of Concept( 原文详尽且形象 )"></a>The Fundamental of Concept( 原文详尽且形象 )</h3><h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1.Overview"></a>1.Overview</h4><h4 id="2-Business-Understanding"><a href="#2-Business-Understanding" class="headerlink" title="2. Business Understanding"></a>2. Business Understanding</h4><h4 id="3-Data-Understanding"><a href="#3-Data-Understanding" class="headerlink" title="3. Data Understanding"></a>3. Data Understanding</h4><h4 id="4-Data-Preparation"><a href="#4-Data-Preparation" class="headerlink" title="4. Data Preparation"></a>4. Data Preparation</h4><h4 id="5-Modeling"><a href="#5-Modeling" class="headerlink" title="5. Modeling"></a>5. Modeling</h4><h4 id="6-Model-Evaluation"><a href="#6-Model-Evaluation" class="headerlink" title="6. Model Evaluation"></a>6. Model Evaluation</h4><h4 id="7-Model-Depolyment"><a href="#7-Model-Depolyment" class="headerlink" title="7. Model Depolyment"></a>7. Model Depolyment</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Day-01&quot;&gt;&lt;a href=&quot;#Day-01&quot; class=&quot;headerlink&quot; title=&quot;Day 01&quot;&gt;&lt;/a&gt;Day 01&lt;/h2&gt;&lt;h3 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;大四一年所作的工作于论文都是基于：CV+MachingLearning, 回头去看，收获很多但是也深切感受到自己当初拖着课题几乎是盲目的去工作，走了很多弯路，自己也缺乏完整的知识体系，恰巧在机器之心上看到一封开源教材 Getting Started With Maching Learning 来自SAP（全球第一大商业软件公司）的梁劲（Jim Liang）公开了自己所写的一份 520 页的学习教程（英文版），详细、明了地介绍了机器学习中的相关概念、数学知识和各种经典算法。准备以此为脉络，研究生之前构架自己的知识体系。
    
    </summary>
    
      <category term="专业学习" scheme="https://xycaicaicai.github.io/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Algorithm" scheme="https://xycaicaicai.github.io/tags/Algorithm/"/>
    
      <category term="Machining Learning" scheme="https://xycaicaicai.github.io/tags/Machining-Learning/"/>
    
  </entry>
  
  <entry>
    <title>代办事项</title>
    <link href="https://xycaicaicai.github.io/2018/11/19/%E4%BB%A3%E5%8A%9E%E4%BA%8B%E9%A1%B9/"/>
    <id>https://xycaicaicai.github.io/2018/11/19/代办事项/</id>
    <published>2018-11-19T05:12:59.000Z</published>
    <updated>2020-07-01T12:59:17.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="托福"><a href="#托福" class="headerlink" title="托福"></a>托福<a id="more"></a></h2><table><thead><tr><th>日期</th><th>精听</th><th>精读</th><th>写作</th><th>口语</th><th>单词</th></tr></thead><tbody><tr><td>2018/11/19</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td></tr><tr><td>2018/11/20</td><td>T</td><td>F</td><td>T</td><td>T</td><td>F</td></tr><tr><td>2018/11/21</td><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td></tr><tr><td>2018/11/22</td><td>T</td><td>F</td><td>F</td><td>F</td><td>T</td></tr><tr><td>2018/11/23</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td></tr><tr><td>2018/11/24</td><td>T</td><td>F</td><td>F</td><td>F</td><td>F</td></tr><tr><td>2018/11/25</td><td>T</td><td>T</td><td>T</td><td>F</td><td>T</td></tr><tr><td>2018/11/26</td><td>T</td><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>2018/11/27</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td></tr><tr><td>2018/11/28</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/11/29</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/11/30</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/01</td><td>Drunk</td><td>Drunk</td><td>Drunk</td><td>Drunk</td><td>Drunk</td></tr><tr><td>2018/12/02</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/03</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>2018/12/04</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>2018/12/05</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>2018/12/06</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/07</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/08</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td></tr><tr><td>2018/12/09</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr></tbody></table><h2 id="Topik学习计划"><a href="#Topik学习计划" class="headerlink" title="Topik学习计划"></a>Topik学习计划</h2><table><thead><tr><th>日期</th><th>真题</th><th>单词</th><th>语法</th><th>写作</th><th>网课</th></tr></thead><tbody><tr><td>2018/11/28</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/11/29</td><td>F</td><td>T</td><td>T</td><td>F</td><td>T</td></tr><tr><td>2018/11/30</td><td>T</td><td>T</td><td>T</td><td>F</td><td>T</td></tr><tr><td>2018/11/01</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/11/02</td><td>T</td><td>T</td><td>T</td><td>F</td><td>T</td></tr><tr><td>2018/12/03</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/04</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/05</td><td>F</td><td>T</td><td>T</td><td>F</td><td>F</td></tr><tr><td>2018/12/06</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/07</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/08</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>2018/12/09</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;托福&quot;&gt;&lt;a href=&quot;#托福&quot; class=&quot;headerlink&quot; title=&quot;托福&quot;&gt;&lt;/a&gt;托福
    
    </summary>
    
      <category term="备忘录" scheme="https://xycaicaicai.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="打卡" scheme="https://xycaicaicai.github.io/tags/%E6%89%93%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>什么是欲望</title>
    <link href="https://xycaicaicai.github.io/2018/11/14/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AC%B2%E6%9C%9B/"/>
    <id>https://xycaicaicai.github.io/2018/11/14/什么是欲望/</id>
    <published>2018-11-14T05:14:20.000Z</published>
    <updated>2020-07-01T12:44:25.729Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近又在想一个奇怪的问题，欲望是什么？</p><h3 id="1-引"><a href="#1-引" class="headerlink" title="1.引"></a>1.引</h3><p>  “对欲望不理解，人就永远不能从桎梏和恐惧中解脱出来。如果你摧毁了你的欲望，可能你也摧毁了你的生活。如果你扭曲它，压制它，你摧毁的可能是非凡之美。”</p><h3 id="2-【欲望】"><a href="#2-【欲望】" class="headerlink" title="2.【欲望】"></a>2.【欲望】</h3><p>  新华词典：</p><p>    基本解释：<a id="more"></a>1.希望﹐盼望。 2.想得到某种东西或达到某种目的的要求。</p><p>  Cambridge Dictionary：</p><pre><code>to want something, especially strongly</code></pre><h3 id="3-是什么？"><a href="#3-是什么？" class="headerlink" title="3.是什么？"></a>3.是什么？</h3><p>&emsp;&emsp;词典的定义都是由表面现象得到定义，我想知道的是本质的欲望是什么呢？不管是什么样的思绪和想法，一旦清楚的明白它就可以掌控它，就像之前关于生命我的不解、时常涌出的烦闷都在那天看见那段话之后完全释然</p><p><em>&emsp;&emsp;“我无法接受这个可怜的生命仅仅在无边的宇宙中像一粒微尘一样存在过短短的一段时间然后永远消失不见的残酷事实。荣格说，这个问题不能<br>常想，否则人会疯掉。我却常常想，不由自主，至今尚未疯掉只能说明我的神经质地坚韧，而且不是一般的坚韧。”<br>明白自己的困扰从哪里来、自己的恐惧是因为什么、这种感受又该怎么表述，在这之后，我理解了它，也摆脱了这个问题对我的困扰。</em></p><p>&emsp;&emsp;而【欲望】是什么？我没有找到严谨的定义或者是对于人为什么会被其裹挟，仅仅是生物的本能嘛？不知道，只是随便写写这些乱七八糟的问题，留下一个思绪的线索，如果有一天得以明了，再来补上。</p><p>———————- 11月27日晚 补充—————</p><p>&emsp;&emsp;今天晚上随手翻了翻书正好看到黑格尔在讲精神现象学的时候提到的一段话可以作为现阶段的理解或者是这个问题是不能理解的原因：</p><p><em><br>&emsp;&emsp;将绝对精神的一切内容都理解为了有限事物，理解为了人的绝对本质和人的表象，所以说绝对的本质对它来说变成了一种不可能具有任何规定和谓词的虚空简言之，之前因为李银河那段话而豁然的问题是具体的、可描述的现象，而对于欲望这种组成人的本质难以有一个具体描述或定义。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近又在想一个奇怪的问题，欲望是什么？&lt;/p&gt;
&lt;h3 id=&quot;1-引&quot;&gt;&lt;a href=&quot;#1-引&quot; class=&quot;headerlink&quot; title=&quot;1.引&quot;&gt;&lt;/a&gt;1.引&lt;/h3&gt;&lt;p&gt;  “对欲望不理解，人就永远不能从桎梏和恐惧中解脱出来。如果你摧毁了你的欲望，可能你也摧毁了你的生活。如果你扭曲它，压制它，你摧毁的可能是非凡之美。”&lt;/p&gt;
&lt;h3 id=&quot;2-【欲望】&quot;&gt;&lt;a href=&quot;#2-【欲望】&quot; class=&quot;headerlink&quot; title=&quot;2.【欲望】&quot;&gt;&lt;/a&gt;2.【欲望】&lt;/h3&gt;&lt;p&gt;  新华词典：&lt;/p&gt;
&lt;p&gt;    基本解释：
    
    </summary>
    
      <category term="碎碎念" scheme="https://xycaicaicai.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://xycaicaicai.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>关于生命</title>
    <link href="https://xycaicaicai.github.io/2018/09/14/%E5%85%B3%E4%BA%8E%E7%94%9F%E5%91%BD/"/>
    <id>https://xycaicaicai.github.io/2018/09/14/关于生命/</id>
    <published>2018-09-14T05:13:59.000Z</published>
    <updated>2020-07-01T12:41:36.919Z</updated>
    
    <content type="html"><![CDATA[<p>误删待补<a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;误删待补
    
    </summary>
    
      <category term="碎碎念" scheme="https://xycaicaicai.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://xycaicaicai.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
